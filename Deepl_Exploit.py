# PYTHON DEEPL EXPLOIT

# Before using this DeepL translation script, you will need to install the following libraries.

# 1) Selenium Documentation - Used to automate browser actions:
# https://selenium-python.readthedocs.io/installation.html#detailed-instructions-for-windows-users

    # a) Gecko driver download, which is needed for Selenium: https://github.com/mozilla/geckodriver/releases

    # b) How to put Gecko driver into path: https://stackoverflow.com/questions/40208051/selenium-using-python-geckodriver-executable-needs-to-be-in-path

# 2) Python Docx Documentation - Used to scrape Microsoft Word (.docx files)
# https://python-docx.readthedocs.io/eQu1ckS1lver!n/latest/index.html#user-guide

# 3) Pyperclip Documentation - Used to copy information from the Clipboard into variables:
# https://pypi.org/project/pyperclip/


from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.common.exceptions import NoSuchElementException
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.firefox.firefox_binary import FirefoxBinary
from selenium.webdriver.common.keys import Keys
import os
import pyperclip
from docx import Document


#+++++++++++++++++++++++++++++ USER INPUT ++++++++++++++++++++++++++++++++

# Give the variable the name of your input document and put the input document into the directory of this Python file
input_file_name = "input.docx"

# Choose between EN (English), DE (German), FR (French), ES (Spanish), IT (Italian), NL (Dutch), PL (Polish)
from_language = "EN"
to_language = "DE"

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# This function checks whether any letters are present in a paragraph and returns 1 if so.
def lettercheck(text):
    count = 0
    letters = "abcdefghijklmnopqrstuvwxyz"
    for letter in letters:
        if letter in text:
            count=1
            break
        else:
            continue
    return count

# We find the Document that the User has put into this script's directory. If it isn't there, we terminate the script.
if(os.path.isfile(input_file_name) == False):
    print("Either the input file is not in the scripts directory OR <input_file_name> has the wrong naming.\n")
    exit()

# We open the input document
document = Document(input_file_name)

# Create a list to store all the text from the untranslated word document's paragraphs in
paragraphs = []

# For each paragraph in the documents paragraphs we check whether the length of that paragraph is below 4800 characters, since we don't want to exceed the maximum of 5000 characters that DeepL lets us translate for free. If the paragraph is above 4800 characters, we wait until the next space (" "), in order to split the paragraphs text into two seperate pieces, that will be appended to the paragraphs lists one after the other.

for para in document.paragraphs:

    if len(para.text) < 4800:
        p = para.text
        paragraphs.append(p)

    elif len(para.text) == 0:
        continue

    else:
        para_size = len(para.text)
        p = para.text

        for char in para.text:
            counter+=1
            part_para+=char.text
            if counter > 4800 and char == " ":
                p1 = part_para.text
                paragraphs.append(p)
                part_para = ""
                tracker+= counter
                counter = 0
            elif tracker == para_size:
                p1 = part_para.text
                paragraphs.append(p)
            else:
                continue


# Start up Selenium

binary = FirefoxBinary(r"C:\Program Files\Mozilla Firefox\Firefox.exe")
driver = webdriver.Firefox(firefox_binary=binary, executable_path=r"C:\Users\maxwe\AppData\Roaming\Mozilla\geckodriver.exe")

# We navigate to the DeepL website with geckobrowser and change the translator to our desired settings
driver.get("https://www.deepl.com/translator#" + from_language + "/" + to_language + "/" + "%0A")

# Check if we got to the DeepL website
assert "DeepL" in driver.title # Check whether it actually is on the DeepL website



# This is where the translation of the document's paragraphs is performed in DeepL
# We first define a list called "translation" that will store all our translated paragraphs. Next, we iterate through all the paragraphs in our paragraph list and check whether they have letters in them. If they dont, they are not translated and aren't added to the translation list.
# If the paragraphs do have letters in them, we find the input field on the DeepL website, click the box to register an input, and input our paragraph. We try to wait for the "busy indicator" to dissapear, which signals that the translation is complete, and click the target text box, where our translated text is stored. We copy this text and save it in a variable called "trans". Finally, we delete the input field's values and start over.
translation = []
for paragraph in paragraphs:
    lettercount = lettercheck(paragraph)
    if lettercount == 0:
        continue

    else:
        # Find input field an paste paragraph
        elem = driver.find_element_by_xpath("//textarea[@class='lmt__textarea lmt__source_textarea lmt__textarea_base_style']")
        elem.click()
        elem.send_keys(paragraph)

        try:

            elem = WebDriverWait(driver, 20).until(EC.invisibility_of_element((By.CLASS_NAME, "lmt__busy_indicator")))
            elem = driver.find_element_by_xpath("//textarea[@class='lmt__textarea lmt__target_textarea lmt__textarea_base_style ']")
            elem.click()
            elem.send_keys(Keys.CONTROL, "a")
            elem.send_keys(Keys.CONTROL, "c")


            trans = pyperclip.paste()
            translation.append(trans)

            #  Find input field and delete former input
            try:
                elem = driver.find_element_by_xpath("//textarea[@class='lmt__textarea lmt__source_textarea lmt__textarea_base_style']")
                elem.click()
                elem.send_keys(Keys.CONTROL, "a")
                elem.send_keys(Keys.BACKSPACE)
            except:
                elem = driver.find_element_by_xpath("//textarea[@class='lmt__textarea lmt__source_textarea lmt__textarea_base_style lmt__textarea--inactive']")
                elem.click()
                elem.send_keys(Keys.CONTROL, "a")
                elem.send_keys(Keys.BACKSPACE)

        # Catch the exception case tha no more input is posted into the input field and the output field is unavailable. This should only happen when the document is over.
        except NoSuchElementException:
            continue


# After all paragraphs have been translated, we proceed to check whether a file called "output.docx" is already in the directory of our script and, if so, delete it.
output = "output.docx"
if(os.path.isfile(output) == True):
    os.unlink(output)
    print("Deleted old output file... \n")

# Afterwards, we open a new document called output.docx. For every item in our translation list, we check whether DeepL has attached an annoying advertising sentence to the end and remove it, if that is the case.
output = Document()
print("...And created new one. \n")
for item in translation:

    if item.endswith("www.DeepL.com/Translator"):
        result = ""
        split = item.split("\n")
        for snippets in split[0:-1]:
            result += " " + snippets
        unstyled = output.add_paragraph(result + "\n")

    else:
        unstyled = output.add_paragraph(item)

# We save the output and we are done.
output.save('output.docx')



# FUTURE IMPROVEMENTS:
"""
- Tables are currently not formatted correctly and are instead inserted into the output document as seperate paragraphs. This is pretty annoying and should be fixed in the next version.

- No paragraph formatting is kept after translation. This can be fixed by copying the "style" attribute of the individual runs in a paragraph. To do so, we could try to split a paragraph into a run for each word and then copying the styling of each run.

- No pictures are transferred into the output word document
"""


